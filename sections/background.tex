\subsection*{Background}

Representing the popularity trends of various web development frameworks over a period from 2016 to 2019

React, known for its robust ecosystem and backing by Facebook, has consistently held a significant share of popularity, while Vue.js has emerged as a strong contender with its approachable learning curve and incremental adoptability. Meanwhile, Svelte, the newest among them, presents an innovative approach by shifting work to compile time, leading to faster runtime performances.

To ensure a consistent standard of functionality across the web pages developed using each framework, Test-Driven Development (TDD) was employed as an aspect of our comparative analysis. This approach guaranteed that, although different frameworks were used, each implementation adhered to the same functional specifications. By integrating TDD into our workflow, we were able to provide a more objective measure of each framework's capabilities, taking into account not only the end product but also the development process itself.

In our analysis of front-end frameworks, we selected a weather application as our use case, primarily because it allows for practical experimentation with public APIs. This choice provided a tangible means to assess and compare the capabilities of various frameworks in handling real-time data, user interface dynamics, and responsiveness. The weather application scenario was particularly suited for this comparison as it involved fetching and displaying data from external sources, a common requirement in modern web development. This setup enabled us to evaluate how different the frameworks React, Svelte and Vue.js manage data binding, state management, and overall performance. Additionally, the integration with public APIs served as an excellent benchmark for understanding the ease of use, flexibility, and scalability offered by each framework, making our comparison comprehensive and relevant to current industry trends.

Central to our approach was the utilization of client-side operations, primarily fetching data from various APIs. The decision to not set up a dedicated backend allowed us to concentrate on the frontend functionalities, exploring how each framework handles tasks like API calls, data processing, and DOM manipulation. By simulating real-world scenarios where frontend applications interact with existing APIs, we were able to assess the efficiency, ease of integration, and responsiveness of each framework in handling client-side operations.
